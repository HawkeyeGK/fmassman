@page "/goalkeepers"

@using fmassman.Shared
@using fmassman.Client.Models
@using fmassman.Client.Helpers
@using fmassman.Client.Components.Shared
@using fmassman.Client.Services
@inject IRosterRepository Repository
@inject IRoleService RoleService


<PageTitle>Goalkeeper Analysis</PageTitle>

<h1>Goalkeeper Analysis</h1>



@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="alert alert-danger">
        <h4>Error Loading Analysis</h4>
        <p>@errorMessage</p>
    </div>
}

@if (matrixItems == null && string.IsNullOrEmpty(errorMessage))
{
    <p><em>Loading...</em></p>
}
else if (matrixItems != null)
{
    @if (matrixItems.Count == 0)
    {
        <div class="alert alert-info">No Goalkeepers found in the roster.</div>
    }
    else
    {
        <RoleMatrixTable Items="@matrixItems" Columns="@columns" />
    }
}

@code {
    private List<MatrixItem>? matrixItems;
    private List<MatrixColumn> columns = new();
    private List<RoleDefinition> allRoles = new();
    private string errorMessage = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            // Load roles so calculator works
            try 
            { 
                allRoles = await RoleService.LoadLocalRolesAsync(); 
            } 
            catch { }



            var roster = await Repository.LoadAsync();
            
            var goalkeepers = roster
                .Where(p => p.Snapshot != null && p.Snapshot.Goalkeeping != null)
                .ToList();

            if (goalkeepers.Count == 0)
            {
                matrixItems = new List<MatrixItem>();
                return;
            }

            // Analyze all players
            // We use a temporary structure to hold analysis to avoid re-running it for column gen
            var analyzedPlayers = new List<(string Name, PlayerAnalysis Analysis)>();
            
            foreach (var p in goalkeepers)
            {
                analyzedPlayers.Add((p.PlayerName, PlayerAnalyzer.Analyze(p.Snapshot!)));
            }
            
            // Generate Columns from the first player
            var templateAnalysis = analyzedPlayers.First().Analysis;
            
            columns = new List<MatrixColumn>();
            
            // Source 1: In Possession
            foreach (var fit in templateAnalysis.InPossessionFits)
            {
                columns.Add(new MatrixColumn($"In Poss_{fit.RoleName}", fit.RoleName, "Goalkeeper", "In Poss"));
            }
            
            // Source 2: Out Possession
            foreach (var fit in templateAnalysis.OutPossessionFits)
            {
                columns.Add(new MatrixColumn($"Out Poss_{fit.RoleName}", fit.RoleName, "Goalkeeper", "Out Poss"));
            }
            
            // Sort Columns: Phase (In then Out), then RoleName
            columns = columns
                .OrderBy(c => c.Phase)
                .ThenBy(c => c.Name)
                .ToList();

            // Build Rows
            matrixItems = new List<MatrixItem>();
            foreach (var item in analyzedPlayers)
            {
                var scores = new Dictionary<string, double>();
                
                foreach (var fit in item.Analysis.InPossessionFits)
                {
                    scores[$"In Poss_{fit.RoleName}"] = fit.Score;
                }
                
                foreach (var fit in item.Analysis.OutPossessionFits)
                {
                    scores[$"Out Poss_{fit.RoleName}"] = fit.Score;
                }
                
                matrixItems.Add(new MatrixItem
                {
                    Name = item.Name,
                    Scores = scores
                });
            }

            // Initial sort handled by component (default Player ASC)
        }
        catch (Exception ex)
        {
            errorMessage = $"Error loading data: {ex.Message}";
        }
    }


}
