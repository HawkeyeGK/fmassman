@page "/goalkeepers"

@using fmassman.Shared
@using fmassman.Client.Models
@using fmassman.Client.Helpers
@using fmassman.Client.Components.Shared
@using fmassman.Client.Components.Controls
@using fmassman.Client.Services
@inject IRosterRepository Repository
@inject IRoleService RoleService
@inject ITagRepository TagRepository


<PageTitle>Goalkeeper Analysis</PageTitle>

<h1>Goalkeeper Analysis</h1>



@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="alert alert-danger">
        <h4>Error Loading Analysis</h4>
        <p>@errorMessage</p>
    </div>
}

@if (matrixItems == null && string.IsNullOrEmpty(errorMessage))
{
    <p><em>Loading...</em></p>
}
else if (matrixItems != null)
{
    @if (matrixItems.Count == 0)
    {
        <div class="alert alert-info">No Goalkeepers found in the roster.</div>
    }
    else
    {
        <TagFilter AllTags="_allTags" @bind-SelectedTagIds="_selectedTagIds" OnChange="ApplyFilter" />
        <RoleMatrixTable Items="@FilteredMatrixItems" Columns="@columns" NameClass="@GetNameClass" />
    }
}

@code {
    private List<MatrixItem>? matrixItems;
    private List<MatrixColumn> columns = new();
    private List<RoleDefinition> allRoles = new();
    private string errorMessage = string.Empty;

    // Tags
    private List<TagDefinition> _allTags = new();
    private List<string> _selectedTagIds = new();

    private List<MatrixItem> FilteredMatrixItems
    {
        get
        {
            if (matrixItems == null) return new();
            if (_selectedTagIds == null || !_selectedTagIds.Any()) return new();

            return matrixItems
                .Where(i => i.TagIds.Intersect(_selectedTagIds).Any())
                .ToList();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            // Load roles so calculator works
            try { allRoles = await RoleService.LoadLocalRolesAsync(); } catch { }
            
            // Load Tags
            _allTags = await TagRepository.GetAllAsync();
            _allTags = _allTags.OrderBy(t => t.Name).ToList();

            // Set Defaults
            SetDefaultTags();


            var roster = await Repository.LoadAsync();
            
            var goalkeepers = roster
                .Where(p => p.Snapshot != null && p.Snapshot.Goalkeeping != null)
                .ToList();

            if (goalkeepers.Count == 0)
            {
                matrixItems = new List<MatrixItem>();
                return;
            }

            // Analyze all players
            // We use a temporary structure to hold analysis to avoid re-running it for column gen
            var analyzedPlayers = new List<(string Name, List<string> TagIds, PlayerAnalysis Analysis)>();
            
            foreach (var p in goalkeepers)
            {
                analyzedPlayers.Add((p.PlayerName, p.TagIds, PlayerAnalyzer.Analyze(p.Snapshot!)));
            }
            
            // Generate Columns from the first player
            var templateAnalysis = analyzedPlayers.First().Analysis;
            
            columns = new List<MatrixColumn>();
            
            // Source 1: In Possession
            foreach (var fit in templateAnalysis.InPossessionFits)
            {
                columns.Add(new MatrixColumn($"In Poss_{fit.RoleName}", fit.RoleName, "Goalkeeper", "In Poss"));
            }
            
            // Source 2: Out Possession
            foreach (var fit in templateAnalysis.OutPossessionFits)
            {
                columns.Add(new MatrixColumn($"Out Poss_{fit.RoleName}", fit.RoleName, "Goalkeeper", "Out Poss"));
            }
            
            // Sort Columns: Phase (In then Out), then RoleName
            columns = columns
                .OrderBy(c => c.Phase)
                .ThenBy(c => c.Name)
                .ToList();

            // Build Rows
            matrixItems = new List<MatrixItem>();
            foreach (var item in analyzedPlayers)
            {
                var scores = new Dictionary<string, double>();
                
                foreach (var fit in item.Analysis.InPossessionFits)
                {
                    scores[$"In Poss_{fit.RoleName}"] = fit.Score;
                }
                
                foreach (var fit in item.Analysis.OutPossessionFits)
                {
                    scores[$"Out Poss_{fit.RoleName}"] = fit.Score;
                }
                
                matrixItems.Add(new MatrixItem
                {
                    Name = item.Name,
                    TagIds = item.TagIds != null ? new List<string>(item.TagIds) : new(),
                    Scores = scores
                });
            }

            // Initial sort handled by component (default Player ASC)
        }
        catch (Exception ex)
        {
            errorMessage = $"Error loading data: {ex.Message}";
        }
    }

    private void SetDefaultTags()
    {
        var defaults = _allTags.Where(t => t.IsDefault).Select(t => t.Id).ToList();
        if (defaults.Any())
        {
            _selectedTagIds = defaults;
        }
        else
        {
            _selectedTagIds = _allTags.Where(t => t.IsRostered).Select(t => t.Id).ToList();
            if (!_selectedTagIds.Any()) 
            {
                _selectedTagIds = _allTags.Select(t => t.Id).ToList();
            }
        }
    }

    private void ApplyFilter()
    {
        // Re-render
    }

    private string GetNameClass(MatrixItem item)
    {
        var playerTags = _allTags.Where(t => item.TagIds.Contains(t.Id)).ToList();
        if (playerTags.Any(t => t.IsArchived)) return "text-danger";
        if (!playerTags.Any(t => t.IsRostered)) return "text-info";
        return "text-white";
    }


}
