@page "/tag-assignments"
@attribute [Microsoft.AspNetCore.Authorization.Authorize]
@using fmassman.Shared
@using fmassman.Client.Components.Controls
@using Microsoft.AspNetCore.Components.QuickGrid
@inject IRosterRepository RosterService
@inject ITagRepository TagRepository

<h3>Player Tags</h3>

<div class="mb-3">
    <TagFilter AllTags="tags" @bind-SelectedTagIds="filterTagIds" />
</div>

@if (allPlayers == null || tags == null)
{
    <div class="text-center">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>
}
else
{
    <div class="grid-scroll-container">
        <QuickGrid Items="@FilteredPlayers" Class="table table-striped table-hover table-sm" Pagination="@pagination">
            <TemplateColumn Title="Player" SortBy="@nameSort" Class="align-middle">
                <div>
                    @context.PlayerName
                </div>
            </TemplateColumn>
            
            @foreach (var tag in tags)
            {
                var currentTag = tag; // Capture variable for closure
                <TemplateColumn Title="@currentTag.Name" SortBy="@GetTagSort(currentTag.Id)" Class="align-middle text-center">
                    <input type="checkbox" 
                           checked="@context.TagIds.Contains(currentTag.Id)" 
                           @onchange="@(e => ToggleTag(context, currentTag.Id, e.Value))" />
                </TemplateColumn>
            }
        </QuickGrid>
    </div>
    <Paginator State="@pagination" />

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="alert alert-danger mt-3">@errorMessage</div>
    }
}

@code {
    private List<PlayerImportData> allPlayers;
    private List<TagDefinition> tags;
    private List<string> filterTagIds = new();
    private string errorMessage;
    private PaginationState pagination = new PaginationState { ItemsPerPage = 20 };

    // Sort rule for Player Name
    private static readonly GridSort<PlayerImportData> nameSort = 
        GridSort<PlayerImportData>.ByAscending(p => GetSortName(p));

    private GridSort<PlayerImportData> GetTagSort(string tagId)
    {
        return GridSort<PlayerImportData>
            .ByDescending(p => p.TagIds.Contains(tagId))
            .ThenAscending(p => GetSortName(p));
    }

    private static string GetSortName(PlayerImportData player)
    {
        var rawName = player.PlayerName.Trim();
        var lastSpaceIndex = rawName.LastIndexOf(' ');
        return (lastSpaceIndex > 0)
            ? $"{rawName.Substring(lastSpaceIndex + 1)}, {rawName.Substring(0, lastSpaceIndex)}"
            : rawName;
    }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            var tagsTask = TagRepository.GetAllAsync();
            var playersTask = RosterService.LoadAsync();

            await Task.WhenAll(tagsTask, playersTask);

            tags = tagsTask.Result.OrderBy(t => t.Name).ToList();
            allPlayers = playersTask.Result.OrderBy(p => p.PlayerName).ToList();

            // Ensure TagIds is not null
            foreach (var p in allPlayers)
            {
                if (p.TagIds == null) p.TagIds = new List<string>();
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load data: {ex.Message}";
        }
    }

    private IQueryable<PlayerImportData> FilteredPlayers
    {
        get
        {
            if (allPlayers == null) return Enumerable.Empty<PlayerImportData>().AsQueryable();

            var query = allPlayers.AsQueryable();

            if (filterTagIds != null && filterTagIds.Any())
            {
                 query = query.Where(p => p.TagIds.Any(tId => filterTagIds.Contains(tId)));
            }

            return query;
        }
    }

    private async Task ToggleTag(PlayerImportData player, string tagId, object checkedValue)
    {
        bool isChecked = (bool)checkedValue;
        bool changed = false;

        // Optimistic update
        if (isChecked)
        {
            if (!player.TagIds.Contains(tagId))
            {
                player.TagIds.Add(tagId);
                changed = true;
            }
        }
        else
        {
            if (player.TagIds.Contains(tagId))
            {
                player.TagIds.Remove(tagId);
                changed = true;
            }
        }

        if (changed)
        {
            try
            {
                errorMessage = null; // Clear previous errors
                await RosterService.UpdatePlayerTagsAsync(player.PlayerName, player.TagIds);
            }
            catch (Exception ex)
            {
                // Revert on failure
                if (isChecked)
                    player.TagIds.Remove(tagId);
                else
                    player.TagIds.Add(tagId);

                errorMessage = $"Failed to update tag for {player.PlayerName}: {ex.Message}";
                // Force UI update to show reverted state if it doesn't happen automatically
                StateHasChanged(); 
            }
        }
    }
}
