@page "/tag-assignments"
@attribute [Microsoft.AspNetCore.Authorization.Authorize]
@using fmassman.Shared
@using fmassman.Client.Components.Controls
@using fmassman.Shared.Models
@using fmassman.Client.Services
@using Microsoft.AspNetCore.Components.QuickGrid
@inject IRosterRepository RosterService
@inject ITagRepository TagRepository
@inject IPositionService PositionService



<div class="mb-3">
    <TagFilter AllTags="tags" @bind-SelectedTagIds="filterTagIds" />
</div>

@if (allPlayers == null || tags == null)
{
    <div class="text-center">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>
}
else
{
    <div class="grid-scroll-container">
        <QuickGrid Items="@FilteredPlayers" Class="table table-striped table-hover table-sm" Pagination="@pagination">
            <TemplateColumn Title="Player" SortBy="@nameSort" Class="align-middle">
                <div style="white-space:nowrap; overflow: hidden; text-overflow: ellipsis;" title="@context.PlayerName">
                    <a href="/player/@context.PlayerName" class="text-decoration-none fw-bold text-white">@context.PlayerName</a>
                </div>
            </TemplateColumn>
            
            <TemplateColumn Title="Position" Class="align-middle">
                 <select class="form-select form-select-sm" 
                        style="@GetStyleForPosition(context.PositionId)"
                        value="@context.PositionId" 
                        @onchange="@(e => UpdatePosition(context, e))">
                    <option value="">Select Position...</option>
                    @if (positions != null)
                    {
                        @foreach (var pos in positions)
                        {
                            <option value="@pos.Id">@pos.Name</option>
                        }
                    }
                </select>
            </TemplateColumn>
            
            @foreach (var tag in tags)
            {
                var currentTag = tag; // Capture variable for closure
                <TemplateColumn Title="@currentTag.Name" SortBy="@GetTagSort(currentTag.Id)" Class="align-middle text-center">
                    <input type="checkbox" 
                           checked="@context.TagIds.Contains(currentTag.Id)" 
                           @onchange="@(e => ToggleTag(context, currentTag.Id, e.Value))" />
                </TemplateColumn>
            }
        </QuickGrid>
    </div>
    <Paginator State="@pagination" />

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="alert alert-danger mt-3">@errorMessage</div>
    }
}

@code {
    private List<PlayerImportData>? allPlayers;
    private List<TagDefinition>? tags;
    private List<PositionDefinition>? positions;
    private List<string> filterTagIds = new();
    private string? errorMessage;
    private PaginationState pagination = new PaginationState { ItemsPerPage = 20 };

    // Sort rule for Player Name
    private static readonly GridSort<PlayerImportData> nameSort = 
        GridSort<PlayerImportData>.ByAscending(p => GetSortName(p));

    private GridSort<PlayerImportData> GetTagSort(string tagId)
    {
        return GridSort<PlayerImportData>
            .ByDescending(p => p.TagIds.Contains(tagId))
            .ThenAscending(p => GetSortName(p));
    }

    private static string GetSortName(PlayerImportData player)
    {
        var rawName = player.PlayerName.Trim();
        var lastSpaceIndex = rawName.LastIndexOf(' ');
        return (lastSpaceIndex > 0)
            ? $"{rawName.Substring(lastSpaceIndex + 1)}, {rawName.Substring(0, lastSpaceIndex)}"
            : rawName;
    }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            var tagsTask = TagRepository.GetAllAsync();
            var playersTask = RosterService.LoadAsync();
            var positionsTask = PositionService.GetAllAsync();

            await Task.WhenAll(tagsTask, playersTask, positionsTask);

            tags = tagsTask.Result.OrderBy(t => t.DisplayOrder).ThenBy(t => t.Name).ToList();
            allPlayers = playersTask.Result.OrderBy(p => p.PlayerName).ToList();
            positions = positionsTask.Result.OrderBy(p => p.Name).ToList();

            // Ensure TagIds is not null
            foreach (var p in allPlayers)
            {
                if (p.TagIds == null) p.TagIds = new List<string>();
            }
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load data: {ex.Message}";
        }
    }

    private IQueryable<PlayerImportData> FilteredPlayers
    {
        get
        {
            if (allPlayers == null) return Enumerable.Empty<PlayerImportData>().AsQueryable();

            var query = allPlayers.AsQueryable();

            if (filterTagIds != null && filterTagIds.Any())
            {
                 query = query.Where(p => p.TagIds.Any(tId => filterTagIds.Contains(tId)));
            }

            return query;
        }
    }

    private async Task ToggleTag(PlayerImportData player, string tagId, object? checkedValue)
    {
        if (checkedValue == null) return;
        bool isChecked = (bool)checkedValue;
        bool changed = false;

        // Optimistic update
        if (isChecked)
        {
            if (!player.TagIds.Contains(tagId))
            {
                player.TagIds.Add(tagId);
                changed = true;
            }
        }
        else
        {
            if (player.TagIds.Contains(tagId))
            {
                player.TagIds.Remove(tagId);
                changed = true;
            }
        }

        if (changed)
        {
            try
            {
                errorMessage = null; // Clear previous errors
                await RosterService.UpdatePlayerTagsAsync(player.PlayerName, player.TagIds);
            }
            catch (Exception ex)
            {
                // Revert on failure
                if (isChecked)
                    player.TagIds.Remove(tagId);
                else
                    player.TagIds.Add(tagId);

                errorMessage = $"Failed to update tag for {player.PlayerName}: {ex.Message}";
                // Force UI update to show reverted state if it doesn't happen automatically
                StateHasChanged(); 
            }
        }
    }
    
    private string GetStyleForPosition(string? positionId)
    {
        if (string.IsNullOrEmpty(positionId)) return "";
        var pos = positions?.FirstOrDefault(p => p.Id == positionId);
        if (pos == null) return "";
        // Use border color to indicate position
        return $"border-left: 5px solid {pos.ColorHex};";
    }

    private async Task UpdatePosition(PlayerImportData player, ChangeEventArgs e)
    {
        var newPosId = e.Value?.ToString();
        if (string.IsNullOrWhiteSpace(newPosId)) newPosId = null;

        var oldPosId = player.PositionId;
        
        // Optimistic update
        player.PositionId = newPosId;

        try
        {
            errorMessage = null; 
            // We cast RosterService to ApiRosterService or we add the method to IRosterRepository?
            // IRosterRepository (Shared) now has UpdatePlayerPositionAsync.
            // So we can use RosterService.UpdatePlayerPositionAsync
            await RosterService.UpdatePlayerPositionAsync(player.PlayerName, newPosId);
        }
        catch (Exception ex)
        {
            // Revert
            player.PositionId = oldPosId;
            errorMessage = $"Failed to update position for {player.PlayerName}: {ex.Message}";
            StateHasChanged();
        }
    }
}
