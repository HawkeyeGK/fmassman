@page "/out-possession"
@rendermode InteractiveServer
@using fmassman.Shared
@using fmassman.Web.Models
@using fmassman.Web.Helpers
@inject IRosterRepository Repository

<PageTitle>Out of Possession Analysis</PageTitle>

<h1>Out of Possession Analysis</h1>

@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="alert alert-danger">
        <h4>Error Loading Analysis</h4>
        <p>@errorMessage</p>
    </div>
}

@if (matrixItems == null && string.IsNullOrEmpty(errorMessage))
{
    <p><em>Loading...</em></p>
}
else if (matrixItems != null)
{
    <div class="grid-scroll-container">
        <table class="table table-bordered table-dark table-sm table-hover mb-0">
            <thead>
                <tr>
                    <th class="sticky-col" style="min-width: 200px; background-color: #2c3034; cursor: pointer;"
                        @onclick='() => SortTable("Player")'>
                        Player <span class="text-warning">@GetSortIndicator("Player")</span>
                    </th>
                    @foreach (var col in columns)
                    {
                        <th class="text-center" style="min-width: 100px; cursor: pointer;"
                            @onclick="() => SortTable(col.Key)">
                            <div>
                                @col.Name 
                                <span class="text-warning">@GetSortIndicator(col.Key)</span>
                            </div>
                            <div style="font-size: 0.7rem; color: #aaa; font-weight: normal;">@col.Category</div>
                        </th>
                    }
                </tr>
            </thead>
            <tbody>
                @foreach (var player in matrixItems)
                {
                    <tr>
                        <td class="sticky-col" style="background-color: #2c3034; font-weight: bold;">
                            <a href="/player/@player.Name" class="text-decoration-none text-info">@player.Name</a>
                        </td>
                        @foreach (var col in columns)
                        {
                            <td class="matrix-cell" style="@(colorScale?.GetColorStyle(player.GetScore(col.Key)).Replace(";", " !important;") ?? "")">
                                @player.GetScore(col.Key).ToString("F1")
                            </td>
                        }
                    </tr>
                }
            </tbody>
        </table>
    </div>
}

@code {
    private List<MatrixItem>? matrixItems;
    private List<MatrixColumn> columns = new();
    private HeatmapColorScale? colorScale;
    private string errorMessage = string.Empty;

    // Sorting State
    private string currentSortKey = "Player";
    private bool isAscending = true;

    private record MatrixColumn(string Key, string Name, string Category);

    private class MatrixItem
    {
        public string Name { get; set; } = "";
        public Dictionary<string, double> Scores { get; set; } = new();
        public double GetScore(string key)
        {
            return Scores.TryGetValue(key, out var val) ? val : 0;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            var roster = await Repository.LoadAsync();
            if (roster.Count == 0) 
            {
                 // Empty Roster: Build columns from cached roles
                columns = RoleFitCalculator.GetRoles("OutPossession")
                    .OrderBy(r => ScoutingConstants.GetCategoryRank(r.Category)) 
                    .ThenBy(r => r.Name)
                    .Select(r => new MatrixColumn($"{r.Category} - {r.Name}", r.Name, r.Category))
                    .ToList();
                    
                matrixItems = new List<MatrixItem>();
                return;
            }

            // 1. Analyze all players
            var analyzedPlayers = roster
                .Where(p => p.Snapshot != null)
                .Select(p => new { Name = p.PlayerName, Analysis = PlayerAnalyzer.Analyze(p.Snapshot!) })
                .ToList();

            if (analyzedPlayers.Count == 0) 
            {
                 // Empty Analysis: Build columns from cached roles
                columns = RoleFitCalculator.GetRoles("OutPossession")
                    .OrderBy(r => ScoutingConstants.GetCategoryRank(r.Category)) 
                    .ThenBy(r => r.Name)
                    .Select(r => new MatrixColumn($"{r.Category} - {r.Name}", r.Name, r.Category))
                    .ToList();
                    
                matrixItems = new List<MatrixItem>();
                return;
            }

            // 2. Build Columns (Using OutPossessionFits)
            var template = analyzedPlayers.First().Analysis.OutPossessionFits;
            columns = template
                .OrderBy(r => ScoutingConstants.GetCategoryRank(r.Category)) 
                .ThenBy(r => r.RoleName)
                .Select(r => new MatrixColumn($"{r.Category} - {r.RoleName}", r.RoleName, r.Category))
                .ToList();

            // 3. Build Rows
            var items = new List<MatrixItem>();
            foreach (var item in analyzedPlayers)
            {
                var scoreMap = item.Analysis.OutPossessionFits
                    .ToDictionary(r => $"{r.Category} - {r.RoleName}", r => r.Score);

                items.Add(new MatrixItem
                {
                    Name = item.Name,
                    Scores = scoreMap
                });
            }
            
            // 4. Initialize Heatmap
            var allScores = items.SelectMany(i => i.Scores.Values);
            colorScale = new HeatmapColorScale(allScores);

            // Initial Sort
            matrixItems = items.OrderBy(p => p.Name).ToList();
        }
        catch (Exception ex)
        {
            errorMessage = $"Error loading analysis: {ex.Message}";
        }
    }

    private void SortTable(string key)
    {
        if (currentSortKey == key)
        {
            isAscending = !isAscending;
        }
        else
        {
            currentSortKey = key;
            isAscending = (key == "Player");
        }
        ApplySort();
    }

    private void ApplySort()
    {
        if (matrixItems == null) return;

        if (currentSortKey == "Player")
        {
            matrixItems = isAscending 
                ? matrixItems.OrderBy(p => p.Name).ToList()
                : matrixItems.OrderByDescending(p => p.Name).ToList();
        }
        else
        {
            matrixItems = isAscending
                ? matrixItems.OrderBy(p => p.GetScore(currentSortKey)).ThenBy(p => p.Name).ToList()
                : matrixItems.OrderByDescending(p => p.GetScore(currentSortKey)).ThenBy(p => p.Name).ToList();
        }
    }

    private string GetSortIndicator(string key)
    {
        if (currentSortKey != key) return "";
        return isAscending ? "▲" : "▼";
    }
}
